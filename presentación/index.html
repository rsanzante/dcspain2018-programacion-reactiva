<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Reactive Programming: Dealing with Asynchronicity | Decoupled Drupal Days 2018 New York</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/simple.css">
    <link rel="stylesheet" href="assets/css/custom.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="sponsor">
      <img class="ddlogo" src="data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0My42NiA2NSI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiNkZGUzZTY7fS5jbHMtMntmaWxsOiM5Y2FmYjg7fS5jbHMtM3tmaWxsOiM4YTlmYWE7fS5jbHMtNHtmaWxsOiM2ODg4OWM7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5kZWNvdXBsZWQtZHJ1cGFsLWRheXMtbG9nbzwvdGl0bGU+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNNDIuOTEsMzEuNzlDNDAuNjcsMjguODcsMzQsMjAsMzEuMDcsMTVhNDQsNDQsMCwwLDEtNC43My0xMkE0OS4zNyw0OS4zNywwLDAsMSwyMiwxNC4zMUMxOS4yNSwxOSw5LDMyLjc2LDksMzIuNzZIOWEyMS44MywyMS44MywwLDEsMCwzMy45My0xWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuNTEgLTMuMDYpIi8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJNNDEuMzIsMzUuNDhjLTItMi42NC04LjA2LTEwLjYzLTEwLjctMTUuMTVBMzkuNTgsMzkuNTgsMCwwLDEsMjYuMzQsOS41MWE0NC42MSw0NC42MSwwLDAsMS0zLjkyLDEwLjE3Yy0yLjQ5LDQuMjYtMTEuNzgsMTYuNjgtMTEuNzgsMTYuNjhoMGExOS43MywxOS43MywwLDEsMCwzMC42Ny0uODhaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC41MSAtMy4wNikiLz48cGF0aCBjbGFzcz0iY2xzLTMiIGQ9Ik0zOS4yOSwzOS45Yy0xLjc1LTIuMjgtNy05LjE5LTkuMjUtMTMuMWEzNC4xMSwzNC4xMSwwLDAsMS0zLjctOS4zNUEzOC42OSwzOC42OSwwLDAsMSwyMywyNi4yNEMyMC44LDI5LjkyLDEyLjc3LDQwLjY2LDEyLjc3LDQwLjY2aDBhMTcuMDYsMTcuMDYsMCwxLDAsMjYuNTItLjc2WiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuNTEgLTMuMDYpIi8+PHBhdGggY2xhc3M9ImNscy00IiBkPSJNMzcuMzQsNDQuMTNjLTEuNDgtMS45My01LjkyLTcuOC03Ljg2LTExLjEzYTI4Ljk0LDI4Ljk0LDAsMCwxLTMuMTQtNy45NCwzMi43NSwzMi43NSwwLDAsMS0yLjg4LDcuNDdjLTEuODMsMy4xMy04LjY1LDEyLjI1LTguNjUsMTIuMjVoMGExNC40OSwxNC40OSwwLDEsMCwyMi41My0uNjVaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC41MSAtMy4wNikiLz48L3N2Zz4="><span>Reactive Programming: Dealing with Asynchronicity<strong>&nbsp; @sanzante</strong></span>
    </div>
    <div class="reveal">
      <div class="slides">
        <section  data-background-image="assets/images/portada.jpg">
          <div class="wrap-ovl">
            <br>
            <div class="session-title">
              Reactive Programming: Dealing with Asynchronicity
            </div>
            <br>
            <br>
            Ricardo Sanz
            <br>
            <span class="xsmall"> sanzante / tunic</span>
            <br>
          </div>
          <div class="spacer">
        </section>



        <section>
            <img src="assets/images/sanzante.jpg" class="profile-photo">
            <p>
              <span>Ricardo Sanz</span>
              <br>
              <span class="xsmall"><em>Drupal Developer &amp; DevOps</em></span>
              <br>
              <a class="xsmall" href="https://drupal.org/u/tunic" target="_blank">drupal.org/u/tunic</a>
              <br>
              <a class="xsmall" href="https://twitter.com/sanzante" target="_blank">sanzante @ Twitter</a>
            </p>
            <img src="assets/images/metadrop-logo.svg" class="metadrop-logo">
        </section>



        <section>
          <div class="header">
            <span>Reactive Programming</span>
          </div>
          <ul>
            <li class="fragment">A way to manage asynchronicity.</li>
            <li class="fragment">This is NOT a talk about React.</li>
            <li class="fragment">Based on the ReactiveX library.</li>
            <li class="fragment">Usable in many languages in addition to JavaScript: PHP, Java, Scala, C#, C+++, Pyhton and others.</li>
          </ul>
          <aside class="notes">
            <strong>Fine, but.... what does reactive programming really offer?</strong>
          </aside>
        </section>



        <section>
          <div class="header">
            <span>Advantages</span>
          </div>
          <ul>
            <li class="fragment">It greatly simplifies asynchronous working.</li>
            <li class="fragment">Very easy to combine and manage asynchronous data sources.</li>
            <li class="fragment">Generates a shorter, simpler and more intuitive code<sup>*</sup>.</li>
            <li class="fragment">Maintainability.</li>
          </ul>
          <aside class="notes">
            <ul>
              <li></li>
              <li>For example, combining data from different external APIs.</li>
              <li>Ah, that little asterisk? This is true, but you have to 'deprogram' yourself a little bit from the structured, object-oriented programming paradigm.</li>
              <li></li>
            </ul>

            <strong>Fine, but.... What do we mean by asynchronicity?</strong>

          </aside>
        </section>



        <section>
          <div class="header">
            <span>Asynchronicity</span>
          </div>
          <ul>
            <li class="fragment">Unpredictable events over time.</li>
            <li class="fragment">The browser environment is asynchronous.</li>
            <li class="fragment">User interaction (mouse, keyboard, etc).</li>
            <li class="fragment">AJAX.</li>
            <li class="fragment">Timers or animations</li>
            <li class="fragment">WebSockets.</li>
            <li class="fragment">Workers.</li>
          </ul>
          <aside class="notes">
            <ul>
              <li>Events that happen over time that we can't predict. This is very common in the browser because it's an asynchronous environment. If we examine a Druapl request we find that the exeuction path is more o less predictible (complex but predictible), and data is available when needed (when a database query is done we asume that result, success or failure, is available in the next line of code, the same for reading a file). In browser this is not true. We don't know when many operations will return their data: AJAX operations are the main example, but it's the same for workers, for example. User interaction, WebSockets, timers and animations are other sources of asynchronicty. </li>
            </ul>
            <strong>How we can manage this uncertainty, this asynchronicty?</strong>

          </aside>
        </section>

        <section>
          <div class="header">
            <span>Callbacks</span>
          </div>
          <ul>
            <li class="fragment">Simple reaction to an event.</li>
            <li class="fragment">
             Function call (listeners).
             <pre>
               <code data-trim>
jQuery('#grip').click(function() {
  jQuery('#panel').slideUp();
});
               </code>
             </pre>
          </li>
           <li class="fragment">Coding complex reactions is hard.</li>
           <li class="fragment"><i>Callback hell</i>.</li>
          </ul>
          <aside class="notes">
            <ul>
              <li>The simple and classic approach.</li>
              <li>When an event is received a function is called. This function process the event and its data. Example: listeners</li>
              <li>Becasue of their simplicity they don't allow many possibilities. Only recommended for simple reactions upon events.</li>
              <li>Things start to get complicated when within a callback you need more actions to process the response that require more callbacks.</li>
            </ul>



          </aside>
        </section>


        <section>
          <div class="header">
            <span>Callback hell</span>
          </div>
            <pre>
              <code data-trim>
var doc;
memStorage.get(docId, response => {
doc = memResponse;
  if (!memResponse) {
    localStorage.get(docId, localResponse => {
      doc = localResponse;
      if (!localResponse) {
        serverStorage.get(docId, serverResponse => {
          doc = serverResponse;
          if (!serverResponse) {
            // Error.
          }
      });
    }
  });
});
              </code>
            </pre>
          <aside class="notes">
            <ul>
              <li>Callback hell is typical from callbacks. It's a nested code because of successive callbacks.</li>
              <li>This code is not easy to read, is not clean and is not elegant.</li>
            </ul>

          <strong>What was the solution to this problem? Promises</strong>

          </aside>
        </section>



        <section>
          <div class="header">
            <span>Promises</span>
          </div>
          <ul>
          <li class="fragment">Objects that wrap synchronous operations and react when there is a result.</li>
          <li class="fragment">They're almost callbacks turned into objects.</li>
          <li class="fragment">They greatly improve flow and error management.</li>
          <li class="fragment">Added to ES2015 (ECMAScript 6).</li>
          </ul>
          <aside class="notes">
            <ul>
              <li>They allow to define a reaction on succees and a reaction on error. They also allow to chain actions for a response.</li>
            </ul>
            <strong>They are a big improvement, but they have certain limitations.</strong>
          <aside>
          </aside>
        </section>



        <section>
          <div class="header">
            <span>Promises</span>
          </div>
          <ul>
            <li class="fragment">They are resolved only once: they return a single value.</li>
            <li class="fragment">Following the execution flow may not be trivial.</li>
            <li class="fragment">They are not lazy.</li>
            <li class="fragment">They are not cancelables.</li>
          </ul>
          <aside class="notes">
          <ul>
            <li>If you want to repeat an action you must run the code that makes the action and processes the response of the promise again. Usually you can do it calling again the function that manages this, so it's not a big deal.. But you'll need to control this re-execution process.<br>
            This works well for managing setTimeouts or simple HTTP request responses, but falls short when dealing with setInterval or WebSockets, for example. Once the promise has been fullfilled it no longer returns more values. </li>
            (https://medium.com/@mpodlasin/promises-vs-observables-4c123c51fe13)
            <li>(https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html)</li>
            <li>As the promise is created the code that tries to solve it is executed immediately. It is assumed that the answer is needed now.</li>
            <li>Except using some libraries like Bluebird, once the promise is created it will try to resolve or fail, but it cannot be cancelled (although it can be ignored, of course). This can result in wasted resources.</li>
          </ul>

          <strong>Although they are a great improvement over callbacks, the following strategy is even more powerful.</strong>
          </aside>
        </section>



        <section>
          <div class="header">
            <span>Reactive programming</span>
          </div>
          <ul>
            <li class="fragment">It brings functional programming capabilities to imperative programming.</li>
            <li class="fragment">Programming using asynchronous data streams.</li>
            <li class="fragment">Declaration of data pipes that process and transform the data that crosses them.</li>
            <li class="fragment">Declaration of reactions to changes.</li>
            <li class="fragment">Similar example: how Angular, React and Vue.js update rendering on data change.</li>
          </ul>
         <aside class="notes">
            <ul>
            </ul>
          <strong>Let's see the necessary concepts.</strong>
          </aside>
        </section>


        <section>
          <div class="header">
            <span>Data pipes</span>
          </div>
          <ul>
            <li class="fragment">The pipe that certain data crosses.</li>
            <li class="fragment">Abstract idea, not a data structure.</li>
          </ul>
          <aside class="notes">
            <strong>What would be a simple pipe?</strong>
          </aside>
        </section>



        <section>
          <div class="header">
            <span>Simple pipe</span>
          </div>
          <div class="fragment">
            <span>Example: Click event listener.</span>
            <pre>
              <code data-trim>
jQuery('#grip').click(function() {
  jQuery('#panel').slideUp();
});
              </code>
            </pre>
            <img  class="fragment" src="assets/images/camino_simple2_en.png">
          </div>
          <aside class="notes">
          This is an example of a very simple data path, the simplest of all. An event is generated in the browser, which is captured and the appropriate action is taken, in this case showing an element of the DOM. There we see a flow of data that goes from the broadcast of the event to its reception in the listener. Nothing mysterious.

          <strong>What would be a complex pipe?</strong>

          </aside>
        </section>



        <section>
          <div class="header">
            <span>Complex pipe</span>
          </div>
          <img src="assets/images/camino_transformaciones_en.png">

          <div class="fragment">
           <span>Example: From a click to an AJAX request, and then to a instantiated object list.
           <img src="assets/images/camino_transformaciones_ejemplo_en.png">
          </div>
          <aside class="notes">
          Pipes with transformations are the interesting ones. For example, the transition from one click to a list of objects loaded from a service. At some point the user clicks a button. This click becomes a URL that serves, for example, a competitions's classification  data list: athletes, points obtained, nationality, name, etc. That URL then becomes the data contained in that URL, which will be a JSON. Following that they are transformed into instances of classes ClassificationAthlete containing the data received. Lastly, the final action occurs, which is to assign these objects to an internal variable. If we use an Angular framework, it will happily paint those objects on the screen once they are assigned to the variable.

          The initial data, a click, has travelled a pipe that has been transforming that data, until the final action, the assignment to a variable. This is nothing new, it's done all the time. Through callbacks or promises, we could chain the output of one calling to another, and deal with the complexity that is produced. The more transformations are made to the data and the more steps there are the more complex the process becomes, especially when these steps also have asynchronous operations.


          <strong>Well, now we have to take a deep breath to get into the thick part of the conversation. How do we create these data paths? How do we declare the reactions to change?</strong>
          </aside>
        </section>



        <section>
          <div class="header">
            <span>Observables/Streams</span>
          </div>
          <ul>
            <li class="fragment">Observables from Observer pattern.</li>
            <li class="fragment">Data streams.</li>
            <li class="fragment">They emmit data until they finish or an error is triggered.</li>
          </ul>
        <aside class="notes">
            First main piece: Observables<br>
            <ul>
              <li>Let's say that are just things that can be observed, boxes where the data comes from, basically they are the observed part of the Observer pattern.</li>
              <li>They are more than just data stream, but I don't want to get into thick technical definitions, so let's say they are data streams</li>
              <li></li>
              In the previous diagrams you could say that they are the little arrows that connect the different boxes. <br>
            </ul>
<!--
          Ben Leash, qués un observable haciendo uno.
          https://medium.com/@benlesh/learning-observable-by-building-observable-d5da57405d87


          https://medium.com/@jshvarts/read-marble-diagrams-like-a-pro-3d72934d3ef5-->

          <strong>Change over time and are difficult to visaulize. Becasue of this, we have the marble diagrams.</strong>

          </aside>
        </section>



        <section>
          <div class="header">
            <span>Marble diagrams</span>
          </div>
          <ul>
            <li class="fragment">Simple way to show data flow over time.</li>
            <li class="fragment">Data flow that emits 4 elements and then finishes.<img src="assets/images/marble_ok.png"></li>
            <li class="fragment">Data flow that emits 3 elements and then emits an error.<img src="assets/images/marble_error.png"></li>
          </ul>
          <aside class="notes">
            Visualizing how data traverses the pipe is very important to understand what is happening. Marble diagrams were designed for this purpose. They are read from left to right, representing time. Each ball is a value emitted by the Observable. The vertical line indicates that the flow has ended, and the cross indicates that it has emitted an error. In both cases the flow is closed.



            https://rxviz.com/examples/mouse-move

          </aside>
        </section>



        <section>
          <div class="header">
            <span>Operators</span>
          </div>
          <ul>
            <li class="fragment">They allow to chain streams.</li>
            <li class="fragment">They allow to transform the stream data.</li>
            <li class="fragment">They allow to modulate streams.</li>
            <li class="fragment">They can create streams.</li>
            <li class="fragment">They can combine streams</li>
          </ul>
          <aside class="notes">
            The second fundamental part is the operators. In the previous diagram they would be the boxes. It is what allows data to be transformed, in more or less complex ways, but it also allows flows to be modulated (for example, preventing data from passing if it does not meet certain properties). They also serve to create Observables (for example, to create an Observable from an event of the DOM, so that when that event occurs the Observable emits the event).

            <strong>Let's see a couple of examples.</strong>
          </aside>
        </section>



        <section>
          <div class="header">
            <span>Operators</span>
          </div>
          <div>
            <span>Filter operator, filters values that don't match the condition.</span>
            <img src="assets/images/marble_filter.png">
          </div>
        </section>



        <section>
          <div class="header">
            <span>Operators</span>
          </div>
          <div>
            <span>Map operator, transforms stream data.</span>
            <img src="assets/images/marble_map.png">
          </div>
          <aside class="notes">
              Si hay tiempo poenr ejemplos interactivos: http://rxmarbles.com/
          <strong>Let's see some code examples</strong>
          </aside>
        </section>



        <section>
          <div class="header">
            <span>Ej: Chronometre</span>
          </div>
          <ul>
            <li class="fragment">Manual chronometre that accumulates time.</li>
            <li class="fragment">A button to enable it.</li>
            <li class="fragment">Another button to pause/continue.</li>
          </ul>
          <div>
              <a class="fragment" href="https://codepen.io/sanzante/pen/gzyMNx">https://codepen.io/sanzante/pen/gzyMNx</a>
          </div>

          <aside class="notes">
          Let's create a chronometre using streams. The example is a bit absurd, it does not show the power of the streams, but it does show how they work.
          </aside>
        </section>


        <section>
          <section>
            <pre>
              <code data-trim data-noescape>
<span class="fragment">var clockValue = 0;</span>
<span class="fragment">var clockOn = true;</span>

<span class="fragment">const btS$ = Rx.Observable.fromEvent(buttonStart, 'click');</span>
<span class="fragment">const btP$ = Rx.Observable.fromEvent(buttonPause, 'click');</span>
<span class="fragment">const clock$ = Rx.Observable.interval(1000);</span>

<span class="fragment">btP$.subscribe(() => clockOn = !clockOn);</span>

<span class="fragment">clock$.subscribe(x => output1.innerHTML = x)</span>

<span class="fragment">clock$.combineLatest(btS$, v => v)</span>
  <span class="fragment">.filter(() => clockOn)</span>
  <span class="fragment">.subscribe(() => output2.innerHTML = ++clockValue);</span>
              </code>
            </pre>
          </section>



          <section>
          <div class="header">
            <span>Event diagram</span>
          </div>
<br>
            <pre>
  clock$  ---1---2---3---4---5---6---7---8---9------>
                    do
          ---1---2---3---4---5---6---7---8---9------>
  btS$    --------x--------------------------------->
                  combineLatest
          --------2--3---4---5---6---7---8---9------>
                  filter (clockOn)
          --------2--3---4---6-----------8---9------>

  btP$    ---------------------x--------x----------->
  clockV  000000001112222333344444444444455556666--->
  clockOn 111111111111111111111000000000011111111--->

            </pre>
          </section>
        </section>



        <section data-background-color="#000000">
          <div class="header">
            <span>Decathlon</span>
          </div>
          <div>
            <img src="assets/images/decathlon.png">
          </div>
          <span>¡Button killer!<span>
        </section>


        <section>
          <div class="header">
            <span>"Button killerism"</span>
          </div>
          <ul>
            <li class="fragment">Detect clicks in a row (double, triple, etc).</li>
            <li class="fragment">Time is counted from the first click.</li>
            <a class="fragment" href="http://jsfiddle.net/aaah4aef/">http://jsfiddle.net/okpjzsfh/</a>
          </ul>
          <aside class="notes">
            Let's do the part that detects when we're crushing the button.
          </aside>
        </section>




        <section>
          <pre>
            <code data-trim data-noescape>
<span class="fragment">var button = document.querySelector('.this');</span>
<span class="fragment">var clickStream = Rx.Observable.fromEvent(button, 'click');</span>
<span class="fragment">var text = document.querySelector('h2');</span>
<span class="fragment">var multiClickStream = clickStream</span>
    <span class="fragment">.buffer(() => Rx.Observable.interval(660))</span>
    <span class="fragment">.map(list => list.length)</span>
    <span class="fragment">.filter(x => x >= 2);</span>

<span class="fragment">multiClickStream.subscribe(numclicks => {
    text.appendChild(createItem(1));
});<span>

<span class="fragment">multiClickStream.delay(3000)</span>
<span class="fragment">    .subscribe(suggestion => {
      text.removeChild(h2elem.firstChild)
    });
</span>
            </code>
          </pre>
        </section>




        <section>
          <div class="header">
            <span>Request URL and instantiate objects</span>
          </div>
          <div>
           <img src="assets/images/camino_transformaciones_ejemplo_en.png">
          </div>
          <pre>
            <code data-trim data-noescape>
<span class="fragment">Rx.Observable.fromEvent(button, 'click')</span>
  <span class="fragment">.map(() => 'https://example.com/api/classification'</span>
  <span class="fragment">.flatMap(url => http.get(url))</span>
  <span class="fragment">.map(items => items.map(new MyItem(item)))</span>
  <span class="fragment">.subscribe(instances => this.list = instances);</span>
            </code>
          </pre>
        </section>



        <section>
          <div class="header">
            <span>Request URL and instantiate objects</span>
          </div>
          <span>Auto refresh</span>
          <pre>
            <code data-trim data-noescape>
<span>Rx.Observable.fromEvent(button, 'click')</span>
<span class="fragment">  .merge(Rx.Observable.interval(60000))</span>
<span class="fragment">  .map(() => 'https://example.com/api/classification'
  .flatMap(url => http.get(url))
  .map(items => items.map(new MyItem(item)))
  .subscribe(instances => this.list = instances);</span>
            </code>
          </pre>
        </section>



        <section>
          <div class="header">
            <span>Request URL and instantiate objects</span>
          </div>
          <span>Deactivatable auto refresh</span>
          <pre>
            <code data-trim data-noescape>
<span class="fragment">Rx.Observable.interval(60000)</span>
  <span class="fragment">.filter(() => this.autorefresh)</span>
  <span class="fragment">.merge(Rx.Observable.fromEvent(button, 'click'))</span>
  <span class="fragment">.map(() => 'https://example.com/api/classification'
  .flatMap(url => http.get(url))
  .map(items => items.map(new MyItem(item)))
  .subscribe(instances => this.list = instances);</span>
            </code>
          </pre>
        </section>




        <section>
          <div class="header">
            <span>Request URL and instantiate objects</span>
          </div>
          <span>Deactivatable auto refresh and error management.</span>
          <pre>
            <code data-trim data-noescape>
<span class="fragment">Rx.Observable.interval(60000)</span>
  <span class="fragment">.filter(() => this.autorefresh)</span>
  <span class="fragment">.merge(Rx.Observable.fromEvent(button, 'click'))
  .map(() => 'https://example.com/api/classification'
  .flatMap(url => http.get(url))
  .map(items => items.map(new MyItem(item)))
  <span class="fragment">.catch(err => Rx.Observable.of([]))
  .subscribe(instances => this.list = instances);</span>
            </code>
          </pre>
        </section>


        <section>
        <div class="header">
          <span>Who to follow</span>
        </div>
        Example from https://gist.github.com/staltz/868e7e9bc2a7b8c1f754
        <ul>
          <li class="fragment">On startup, load accounts data from the API and display 3 suggestions
</li>
          <li class="fragment">On clicking "Refresh", load 3 other account suggestions into the 3 rows
</li>
          <li class="fragment">On click 'x' button on an account row, clear only that current account and display another
</li>
          <li class="fragment">Each row displays the account's avatar and links to their page.</li>
        </ul>
        </section>

        <section>
        <div class="header">
          <span>Who to follow</span>
        </div>
        <img src="assets/images/widget.png">
        </section>



        <section>
          <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754#user-content-wrapping-up"><img class="source-widget" src="assets/images/widget_source_code.png"></a>
        </section>


        <section>
          <div class="header">
            <span>Observables notes</span>
          </div>
          <ul>
            <li class="fragment">They are not EventEmitter.</li>
            <li class="fragment">Can be asyncronous or synchronous.</li>
            <li class="fragment">Can be cold o hot.</li>
            <li class="fragment">Can be multicast o unicast.</li>
            <li class="fragment">Can share or not the data source with their subscriptors.</li>
          </ul>
        </section>


        <section>
          <div class="header">
            <span>Why to adopt?</span>
          </div>

            <div class="fragment">
              Because others have already done it.
              <br>
              <img src="assets/images/adopters.png">
            </div>
        </section>



        <section>
          <div class="header">
            <span>Why to adopt?</span>
          </div>
          <ul>
            <li class="fragment">It can model almost everything.</li>
            <li class="fragment">They handle any data source.</li>
            <li class="fragment">Observables: proposed for standard, currently in stage 1.</li>
            <li class="fragment">Less code, improved maintanibility.</li>
            <li class="fragment">Available in many languages.</li>
            <li class="fragment">Asynchronicity.</li>
          </ul>
        </section>



        <section>
          <div class="header">
            <span>Links</span>
          </div>
          <ul>
            <li class="fragment">The introduction to Reactive Programming you've been missing: https://gist.github.com/staltz/868e7e9bc2a7b8c1f754</li>
            <li class="fragment">Interactive marble diagrams: http://rxmarbles.com/</li>
            <li class="fragment">Rx Visualizer: https://rxviz.com/</li>
            <li class="fragment">ReactiveX: http://reactivex.io/</li>
            <li class="fragment">Ben Lesh: https://medium.com/@benlesh/</li>


          </ul>
        </section>



        <section>
          <div class="header">
            <span>Questions?</span>
          </div>
          <ul>
        </section>



        <section>
          <div class="header">
            <span>¡Thanks!</span>
          </div>
          <ul>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });

          setTimeout(() => Reveal.slide(25), 100);
    </script>

    <!--

     https://github.com/tc39/proposal-observable
     https://blog.hackages.io/rxjs-5-5-piping-all-the-things-9d469d1b3f44

  </body>
</html>
